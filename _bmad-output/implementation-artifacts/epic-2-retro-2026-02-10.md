# Rétrospective Epic 2 — Configuration & Structure de chantier

**Date :** 2026-02-10
**Facilitateur :** Bob (Scrum Master)
**Participants :** Alice (PO), Bob (SM), Charlie (Senior Dev), Dana (QA), Elena (Junior Dev), Youssef (Project Lead)

---

## Résumé Epic 2

- **Stories :** 6/6 complétées (100%)
- **Tests :** 132 → 335 (203 nouveaux, 0 régressions)
- **Tables créées :** 7 nouvelles (plots, variantes, variante_pieces, variante_documents, etages, lots, pieces, taches, lot_documents)
- **Fonctions RPC :** 3 (create_lot_with_inheritance, create_batch_lots_with_inheritance, add_piece_to_lot)
- **Migrations SQL :** 7 (003 à 009)

## Succès

- **RPC atomiques PostgreSQL** — Pattern architectural validé pour les opérations multi-tables. Un seul round-trip réseau, atomicité garantie, pas d'états intermédiaires. Scalable (lot simple → batch).
- **Prévention des doublons systématique** — Validation case-insensitive côté client + contrainte UNIQUE côté SQL. Appliqué dans 4/6 stories, devenu un réflexe.
- **CASCADE on delete** sur toute la hiérarchie (chantier → plot → etage → lot → piece → tache) — zéro données orphelines.
- **Bibliothèque UI shadcn enrichie progressivement** — Sheet, Select, Switch, Badge ajoutés story par story.
- **203 nouveaux tests, 0 régressions** — Discipline de test maintenue.

## Difficultés

- **Restructuration des routes/layouts TanStack Router** — Chaque ajout de niveau hiérarchique nécessitait de convertir des routes en layouts avec Outlet. Le `routeTree.gen.ts` se régénère et peut casser des imports.
- **Polyfills jsdom manquants** — `scrollTo` et `HTMLDialogElement` absents de l'environnement de test (Story 2-5). Temps perdu en debugging.
- **Story 2-4 très dense** — 5 nouvelles tables + RPC + queries relationnelles + page détail + 41 tests. Complexité irréductible mais à anticiper.
- **`match.params` TanStack Router** — Propage TOUS les params à TOUS les niveaux. Piège découvert et documenté dans MEMORY.md.

## Insights clés

1. Privilégier les RPC PostgreSQL pour toute opération atomique multi-table
2. La complexité irréductible doit être acceptée, pas découpée artificiellement — mais flaguée en amont
3. Les polyfills jsdom doivent être centralisés (fichier setup dédié)
4. Le modèle hiérarchique avec CASCADE a parfaitement tenu pour Epic 3

## Suivi des actions Epic 1

- ✅ Audit des composants shadcn après copie — Appliqué (Sheet, Select, Switch vérifiés)
- ✅ Documentation gotchas dans MEMORY.md — Pattern RPC et TanStack Router params ajoutés
- ⏳ Lint error ThemeProvider.tsx:64 — Toujours présent (basse priorité)
- ✅ Patterns TanStack Query comme standard — Suivi dans tous les hooks Epic 2

## Actions

### Améliorations de processus
1. **Flaguer les stories denses en amont** — Marquer les stories 4+ tables ou RPC complexe comme "story dense" au sprint planning. Propriétaire : SM (Bob).
2. **Centraliser les polyfills jsdom** — Fichier `src/test/setup-polyfills.ts`. Propriétaire : Dev (Amelia).

### Dette technique
1. **Lint error ThemeProvider.tsx:64** — Report depuis Epic 1. Priorité basse.

### Accords d'équipe
- Les RPC PostgreSQL atomiques sont le **standard** pour les opérations multi-table
- La prévention des doublons (client + SQL) est systématique
- Les stories à complexité irréductible sont acceptées telles quelles

## Évaluation de maturité

- **Tests & Qualité :** ✅ 335 tests, 0 régressions
- **Déploiement :** ✅ Production continue via Vercel + GitHub Actions
- **Modèle de données :** ✅ Validé par Epic 3 (navigation hiérarchique, agrégation, recherche)
- **Bloqueurs non résolus :** Aucun

## Validation Epic suivante

Le modèle hiérarchique d'Epic 2 a parfaitement supporté Epic 3 (Navigation terrain & Suivi d'avancement). La navigation breadcrumb, le drill-down, le swipe entre pièces, la recherche par lot et les agrégation triggers se sont tous appuyés sur les tables et contraintes d'Epic 2 sans modification de schéma.
